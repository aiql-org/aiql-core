/**
 * Auto-generated examples manifest.
 * Do not edit manually.
 */

export interface Example {
    label: string;
    code: string;
    path: string;
}

export interface ExampleCategory {
    category: string;
    examples: Example[];
}

export const examples: { version: string; categories: ExampleCategory[] } = {
  "version": "2.8.0",
  "categories": [
    {
      "category": "üöÄ Getting Started",
      "examples": [
        {
          "label": "Feature Showcase: Imaginary & Hypothetical Statements",
          "code": "// Feature Showcase: Imaginary & Hypothetical Statements\n// ==============================================================================\n// This file demonstrates how to use AIQL for simulation, imagination, and counterfactuals.\n//\n// Key Concepts:\n// 1. !Assert(mode:hypothetical): Defines statements that are not asserted as true facts\n//    but as temporary assumptions for reasoning.\n// 2. !Hypothesis: A dedicated Intent for scientific or logical hypotheses.\n// 3. !Imagine: A creative Intent for generative or unregulated scenarios.\n// 4. Context Scoping: Using 'scope' to isolate imaginary worlds from the global knowledge base.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Hypothetical Reasoning\n// Goal: Create a temporary assumption to test consequences.\n// Natural Language: \"Let's assume hypothetically that the sun is blue...\"\n// ------------------------------------------------------------------------------\n!Assert(mode:hypothetical, scope:scenario_A) {\n  // These facts do not pollute the global knowledge base.\n  // They exist only within 'scope:scenario_A'.\n  <Sun> [has_color] <Blue>\n  \n  // Logical inference can now run LOCALLY within this scope.\n  // e.g. Plants might evolve to absorb different wavelengths.\n  <Plants> [absorb] <YellowLight>\n} @0.5 // Confidence represents the plausibility of the hypothesis\n\n// ------------------------------------------------------------------------------\n// 2. Simulation Task\n// Goal: Define initial conditions for a physics or logic simulation.\n// Natural Language: \"Run a simulation 'sim_gravity_2x' where gravity is doubled.\"\n// ------------------------------------------------------------------------------\n!Task(type:simulation, id:sim_gravity_2x) {\n  // Setting parameters for the simulation environment.\n  <World> [has_gravity] <2.0g>\n  \n  // Defining expected behaviors or laws in this simulation.\n  <Objects> [fall_acceleration] <19.6m_s2>\n  \n  // Linking this simulation to a specific purpose\n  <Simulation> [tests] <StructuralIntegrity>\n}\n\n// ------------------------------------------------------------------------------\n// 3. Counterfactual History\n// Goal: Model alternative historical timelines (\"What If?\").\n// Natural Language: \"If Napoleon had won the Battle of Waterloo in 1815...\"\n// ------------------------------------------------------------------------------\n!Assert(mode:counterfactual, time:1815, scope:timeline_alt_victory) {\n  <Napoleon> [wins] <BattleOfWaterloo>\n  <FrenchEmpire> [controls] <Europe>\n  \n  // This contradicts real history, so isolation via 'scope' is critical.\n  <BritishEmpire> [suffers] <Defeat>\n}\n\n// ------------------------------------------------------------------------------\n// 4. Scientific Hypothesis\n// Goal: Formally state a falsifiable scientific theory.\n// Natural Language: \"Hypothesis: Dark Matter is composed of Axions.\"\n// ------------------------------------------------------------------------------\n!Hypothesis(field:physics) {\n  <DarkMatter> [composed_of] <Axions>\n  \n  // Metadata can track the status of this hypothesis\n  <Hypothesis> [status] <Untested>\n} @0.6 // Preliminary confidence level\n\n// ------------------------------------------------------------------------------\n// 5. Creative Imagination\n// Goal: Unconstrained generation of concepts for fiction or art.\n// Natural Language: \"Imagine a dragon made of crystal breathing light.\"\n// ------------------------------------------------------------------------------\n!Imagine {\n  // Creative intents allow for \"impossible\" physics or semantics.\n  <Dragon> [made_of] <Crystal>\n  <Dragon> [breathes] <Light>\n  \n  <CrystalDragon> [lives_in] <PrismCave>\n}\n",
          "path": "getting-started/imaginary-statements.aiql"
        },
        {
          "label": "Feature Showcase: Question Statements & Queries",
          "code": "// Feature Showcase: Question Statements & Queries\n// ==============================================================================\n// This file demonstrates the Query capabilities of AIQL.\n//\n// Key Concepts:\n// 1. !Query Intent: The primary mechanism for asking questions.\n// 2. <?Variables>: Placeholders (prefixed with ?) representing unknown values to find.\n// 3. Context Parameters: Scoping queries to specific times, domains, or modes.\n// 4. Meta-Cognition: Querying the AI's own knowledge state.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Basic Fact Retrieval\n// Goal: Find the object of a specific relation.\n// Natural Language: \"What is the capital of France?\"\n// ------------------------------------------------------------------------------\n!Query {\n  // <?City> is the unbound variable the inference engine will solve for.\n  <France> [has_capital] <?City>\n}\n\n// ------------------------------------------------------------------------------\n// 2. Reverse Query\n// Goal: Find the subject when the object is known.\n// Natural Language: \"Which country has Paris as its capital?\"\n// ------------------------------------------------------------------------------\n!Query {\n  // The inference engine searches for any Concept satisfying this pattern.\n  <?Country> [has_capital] <Paris>\n}\n\n// ------------------------------------------------------------------------------\n// 3. Multi-Variable Complex Query\n// Goal: Retrieve multiple related pieces of information simultaneously.\n// Natural Language: \"Who invented the telephone, and in what year?\"\n// ------------------------------------------------------------------------------\n!Query {\n  // We can bind multiple variables in a single graph pattern.\n  // Here, we find the Inventor of the Telephone.\n  // Note: Attributes are currently used for value constraints (filtering).\n  <?Inventor> [invented] <Telephone> {\n    year: 1876\n  }\n}\n\n// ------------------------------------------------------------------------------\n// 4. Contextual Query (Temporal & Spatial)\n// Goal: Limit the search scope to a specific context.\n// Natural Language: \"What is the projected population of Mars in the future?\"\n// ------------------------------------------------------------------------------\n!Query(time:future, scope:system_solar, mode:prediction) {\n  // The 'time:future' parameter tells the engine to look for theoretical \n  // or predictive models rather than current facts.\n  <Mars> [has_population] <?Count>\n}\n\n// ------------------------------------------------------------------------------\n// 5. Boolean Existence Check\n// Goal: Verify if a specific statement is true (Yes/No).\n// Natural Language: \"Does the Electron have a Positive charge?\"\n// ------------------------------------------------------------------------------\n!Query {\n  // If this graph pattern exists in the Knowledge Base, the result is TRUE.\n  // If it contradicts known facts, it is FALSE.\n  // If unknown, it returns UNKNOWN (Open World Assumption).\n  <Electron> [has_charge] <Positive>\n}\n\n// ------------------------------------------------------------------------------\n// 6. Meta-Cognitive Introspection\n// Goal: Ask the AI about its own knowledge gaps or capabilities.\n// Natural Language: \"Do I know anything about Quantum Mechanics?\"\n// ------------------------------------------------------------------------------\n!Query {\n  // <Self> represents the agent's own cognitive state.\n  // [has_knowledge_about] is a meta-relation defined in the ontology.\n  <Self> [has_knowledge_about] <QuantumMechanics>\n}\n\n// ------------------------------------------------------------------------------\n// 7. Logic-Based Query with Constraints\n// Goal: Find items that satisfy logical conditions.\n// Natural Language: \"Find a planet that is habitable AND has water.\"\n// ------------------------------------------------------------------------------\n!Query {\n  // Multiple patterns in a Query block imply an AND relationship.\n  // All patterns must be satisfied for a match.\n  <?Planet> [is] <Habitable>\n  <?Planet> [contains] <Water>\n}\n",
          "path": "getting-started/question-statements.aiql"
        },
        {
          "label": "Multi-Relation Data Pipeline",
          "code": "// Multi-Relation Data Pipeline\n// ==============================================================================\n// This file demonstrates how to model data processing workflows in AIQL.\n//\n// Key Concepts:\n// 1. !Task Intent: Used for procedural or workflow-oriented statements.\n// 2. Chained Relations: Connecting concepts to represent flow (Extraction -> Filtration -> Transformation).\n// 3. Attribute Metadata: Adding specific parameters (like `min_age`) to relations.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// 1. ETL Workflow Definition\n// Goal: Define a sequence of operations to process user data.\n// Natural Language: \"Extract UserData from Database, filter by Age >= 25, then transform to CleanDataset.\"\n// ------------------------------------------------------------------------------\n!Task {\n  // Step 1: Extraction\n  <UserData> [extracted_from] <Database>\n  \n  // Step 2: Filtration\n  // Attributes (min_age: 25) define the criteria for this relationship.\n  <UserData> [filtered_by] <AgeFilter> { \n    min_age: 25 \n  }\n  \n  // Step 3: Transformation\n  <UserData> [transformed_to] <CleanDataset>\n} @0.90 // High confidence in this workflow definition",
          "path": "getting-started/multi-relation-data-pipeline.aiql"
        },
        {
          "label": "Query: Python for Data Science",
          "code": "// Query: Python for Data Science\n// ==============================================================================\n// This file demonstrates a basic knowledge retrieval query in AIQL.\n//\n// Key Concepts:\n// 1. !Query Intent: Asking for confirmation or information about a relationship.\n// 2. Scope: Limiting the query context (here, 'global').\n// 3. Attributes: Providing additional context to the query pattern.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Suitability Query\n// Goal: Confirm if Python is suitable for Data Science.\n// Natural Language: \"Is Python suited for Data Science? (Context: High popularity)\"\n// ------------------------------------------------------------------------------\n!Query(scope:global) {\n  // The engine checks if a relation [is_suited_for] exists between <Python> and <DataScience>.\n  // The attribute { popularity: \"High\" } acts as a constraint or additional context match.\n  <Python> [is_suited_for] <DataScience> {\n    popularity: \"High\"\n  }\n} @0.99 // Expecting high confidence in the result",
          "path": "getting-started/query-python-for-data-science.aiql"
        }
      ]
    },
    {
      "category": "‚è∞ Temporal Tenses",
      "examples": [
        {
          "label": "Temporal Tenses: Complete Reference Card",
          "code": "// Temporal Tenses: Complete Reference Card\n// ==============================================================================\n// This file demonstrates the 12 temporal tenses supported by AIQL relationships.\n// Relation Format: [predicate@tense:value]\n//\n// Full List:\n// - Simple: past, present, future\n// - Perfect: past_perfect, present_perfect, future_perfect\n// - Progressive: past_progressive, present_progressive, future_progressive\n// - Perfect Progressive: past_perfect_progressive, present_perfect_progressive, future_perfect_progressive\n// ==============================================================================\n\n@version:\"1.1.0\"\n\n!Assert {\n  // 1. Simple Tenses\n  <Napoleon> [conquered@tense:past] <Europe>\n  <AI> [transforms@tense:present] <World>\n  <AGI> [will_achieve@tense:future] <Goals>\n  \n  // 2. Perfect Aspect (Completed actions relative to time)\n  <Team> [has_completed@tense:present_perfect] <Sprint>\n  <Company> [had_launched@tense:past_perfect] <Product>\n  <System> [will_have_processed@tense:future_perfect] <Data>\n  \n  // 3. Progressive Aspect (Ongoing actions)\n  <Athlete> [is_running@tense:present_progressive] <Race>\n  <Dev> [was_debugging@tense:past_progressive] <Code>\n  <Bot> [will_be_monitoring@tense:future_progressive] <Metrics>\n  \n  // 4. Perfect Progressive Aspect (Ongoing duration up to a point)\n  <Student> [has_been_studying@tense:present_perfect_progressive] <Math>\n  <Artist> [had_been_creating@tense:past_perfect_progressive] <Art>\n  <AI> [will_have_been_optimizing@tense:future_perfect_progressive] <Models>\n} @1.0",
          "path": "temporal-tenses/all-12-tenses-complete-reference.aiql"
        },
        {
          "label": "Temporal Tenses: Context Integration",
          "code": "// Temporal Tenses: Context Integration\n// ==============================================================================\n// This file demonstrates combining Tense Annotations with Context Parameters.\n//\n// Key Concepts:\n// 1. Tense + Context: Reinforcing the timeline (e.g., [past] + time:1969).\n// 2. Provenance: Citing historical records.\n// 3. Scope: Differentiating 'historical' fact from 'prediction'.\n// ==============================================================================\n\n@version:\"1.1.0\"\n@origin:\"doi:10.1234/history\"\n@cite:[\"Smith2024\", \"NASA_Archives\"]\n\n// ------------------------------------------------------------------------------\n// Historical Context (1969)\n// ------------------------------------------------------------------------------\n!Assert(time:1969, scope:historical) {\n  <Apollo11> [landed@tense:past] <Moon> {\n    date: \"1969-07-20\",\n    location: \"Sea of Tranquility\"\n  }\n  <ArmstrongAldrin> [walked@tense:past] <LunarSurface> {\n    duration: \"2.5 hours\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// Future Context (Prediction)\n// ------------------------------------------------------------------------------\n!Query(time:future, mode:prediction) {\n  <Humanity> [will_establish@tense:future] <MarsColony> {\n    estimated_year: 2040,\n    probability: 0.75\n  }\n} @0.75",
          "path": "temporal-tenses/tense-with-context-historical-timeline.aiql"
        },
        {
          "label": "Temporal Tenses: Historical Events",
          "code": "// Temporal Tenses: Historical Events\n// ==============================================================================\n// This file demonstrates using simple tenses for historical timelines.\n//\n// Key Concepts:\n// 1. Narrative Flow: Mixing past, present, and future perspectives.\n// 2. Simple Tense: Direct statement of fact at a point in time.\n// ==============================================================================\n\n@version:\"1.1.0\"\n\n!Assert {\n  // Past Fact\n  <Napoleon> [conquered@tense:past] <Europe> {\n    year: 1805,\n    campaign: \"Austerlitz\"\n  }\n  \n  // Present Observation\n  <AI> [transforms@tense:present] <Industry> {\n    sector: \"technology\"\n  }\n  \n  // Future Prediction\n  <AGI> [will_achieve@tense:future] <Singularity> {\n    projection: \"optimistic\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// Complex Query Example\n// ------------------------------------------------------------------------------\n!Query {\n  <Scientists> [had_discovered@tense:past_perfect] <Vaccine>\n}",
          "path": "temporal-tenses/temporal-tense-historical-events.aiql"
        },
        {
          "label": "Temporal Tenses: Meta-Reasoning Future Beliefs",
          "code": "// Temporal Tenses: Meta-Reasoning Future Beliefs\n// ==============================================================================\n// This file demonstrates nesting future beliefs about predictions.\n//\n// Key Concepts:\n// 1. Context Params (time:future): The entire assertion is about the future.\n// 2. Mode (mode:possibility): The assertion is probabilistic, not fact.\n// 3. Nested Beliefs: Stating what people *will believe* in the future.\n// ==============================================================================\n\n@version:\"1.1.0\"\n\n// ------------------------------------------------------------------------------\n// Predictive Model\n// ------------------------------------------------------------------------------\n!Assert(time:future, mode:possibility) {\n  <Futurists> [believe] <Prediction> {\n    claim: \"AI will surpass human intelligence\",\n    confidence: 0.75,\n    timeframe: \"2050\",\n    basis: \"exponential_growth\"\n  }\n} @0.80",
          "path": "temporal-tenses/meta-reasoning-future-ai-beliefs.aiql"
        },
        {
          "label": "Temporal Tenses: Perfect Aspect",
          "code": "// Temporal Tenses: Perfect Aspect\n// ==============================================================================\n// This file demonstrates the Perfect aspect (Completion).\n//\n// Key Concepts:\n// 1. Focus: Completion of an action relative to a reference time.\n// 2. Syntax: [predicate@tense:X_perfect]\n// 3. Nuance: Emphasizes the result or state of being finished.\n// ==============================================================================\n\n@version:\"1.1.0\"\n\n!Assert {\n  // Present Perfect (Completed recently / relevance to now)\n  <Scientists> [have_discovered@tense:present_perfect] <Cure> {\n    disease: \"malaria\",\n    impact: \"high\"\n  }\n\n  // Past Perfect (Completed before another past event)\n  <Team> [had_completed@tense:past_perfect] <Project> {\n    deadline: \"Q4_2025\",\n    status: \"delivered\"\n  }\n\n  // Future Perfect (Completed before a future point)\n  <AI> [will_have_learned@tense:future_perfect] <Skills> {\n    by_date: \"2030\",\n    mastery: \"expert\"\n  }\n} @0.95",
          "path": "temporal-tenses/perfect-tenses-completed-actions.aiql"
        },
        {
          "label": "Temporal Tenses: Perfect Progressive",
          "code": "// Temporal Tenses: Perfect Progressive\n// ==============================================================================\n// This file demonstrates the Perfect Progressive aspect.\n//\n// Key Concepts:\n// 1. Focus: Duration and continuity of an action up to a reference point.\n// 2. Syntax: [predicate@tense:X_perfect_progressive]\n// 3. Nuance: Implies effort, duration, and potential ongoing nature.\n// ==============================================================================\n\n@version:\"1.1.0\"\n\n!Assert {\n  // Present Perfect Progressive (Current duration)\n  <Student> [has_been_studying@tense:present_perfect_progressive] <Physics> {\n    duration: \"3 years\",\n    still_ongoing: true\n  }\n\n  // Past Perfect Progressive (Duration before past event)\n  <Artist> [had_been_painting@tense:past_perfect_progressive] <Mural> {\n    duration: \"6 months\",\n    completed_before: \"2025-12-15\"\n  }\n\n  // Future Perfect Progressive (Duration at future point)\n  <AI> [will_have_been_learning@tense:future_perfect_progressive] <Language> {\n    duration: \"10 years\",\n    milestone_date: \"2036-01-01\"\n  }\n} @0.90",
          "path": "temporal-tenses/perfect-progressive-duration-emphasis.aiql"
        },
        {
          "label": "Temporal Tenses: Progressive Aspect",
          "code": "// Temporal Tenses: Progressive Aspect\n// ==============================================================================\n// This file demonstrates the Progressive aspect (Ongoing).\n//\n// Key Concepts:\n// 1. Focus: Action is in progress / continuous / temporary.\n// 2. Syntax: [predicate@tense:X_progressive]\n// 3. Nuance: Frame-by-frame view of an event.\n// ==============================================================================\n\n@version:\"1.1.0\"\n\n!Assert {\n  // Present Progressive (Happening right now)\n  <Athlete> [is_running@tense:present_progressive] <Marathon> {\n    current_location: \"Mile 20\"\n  }\n\n  // Past Progressive (Was happening when interrupted)\n  <Developer> [was_coding@tense:past_progressive] <Feature> {\n    interrupted_by: \"meeting\"\n  }\n\n  // Future Progressive (Will be happening at that time)\n  <Robot> [will_be_working@tense:future_progressive] <Factory> {\n    shift: \"night\",\n    task: \"assembly\"\n  }\n} @0.92",
          "path": "temporal-tenses/progressive-tenses-ongoing-actions.aiql"
        }
      ]
    },
    {
      "category": "üíù Affective Computing",
      "examples": [
        {
          "label": "Affective Computing: Curiosity Threshold",
          "code": "// Affective Computing: Curiosity Threshold\n// ==============================================================================\n// This file demonstrates querying internal affective states with conditions.\n//\n// Key Concepts:\n// 1. Introspection: The agent querying its own feelings.\n// 2. Conditional Query: Checking if an emotion exceeds a threshold.\n// 3. Self-Regulation: Used by agents to decide when to stop/start exploration.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:affective_introspection\n\n// ------------------------------------------------------------------------------\n// 1. Curiosity Check\n// Goal: \"Am I curious enough to continue exploring?\" (Threshold: 0.5)\n// ------------------------------------------------------------------------------\n!Query {\n  <AI> [experiences] <Curiosity> {\n    threshold: 0.5,\n    operator: \">=\"\n  }\n}",
          "path": "affective-computing/affective-query-curiosity-threshold.aiql"
        },
        {
          "label": "Affective Computing: Desire for Knowledge",
          "code": "// Affective Computing: Desire for Knowledge\n// ==============================================================================\n// This file demonstrates goal-directed motivation.\n//\n// Key Concepts:\n// 1. !Desire Intent: Represents future-oriented goals or wants.\n// 2. Domain Specificity: Targeting desire towards a specific field (Quantum Physics).\n// 3. Intrinsic Motivation: The agent \"wants\" to learn, driving autonomous behavior.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Asserting Desire\n// Natural Language: \"The Agent strongly desires knowledge about Quantum Physics.\"\n// ------------------------------------------------------------------------------\n!Assert {\n  <Agent> [desires] <Knowledge> {\n    intensity: 0.85,\n    domain: \"quantum_physics\",\n    motivation_type: \"intrinsic\"\n  }\n} @0.90",
          "path": "affective-computing/affective-state-desire-for-knowledge.aiql"
        },
        {
          "label": "Affective Computing: Joy Expression",
          "code": "// Affective Computing: Joy Expression\n// ==============================================================================\n// This file demonstrates the basic representation of emotional states.\n//\n// Key Concepts:\n// 1. First-Class Emotions: Emotions are semantic entities (<Joy>), not just numbers.\n// 2. Intensity Attributes: Quantifying the strength of the feeling (0.0 - 1.0).\n// 3. !Feels Relation: Specialized relation for internal affective states.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:affective_core\n\n// ------------------------------------------------------------------------------\n// 1. Asserting Joy\n// Goal: The agent expresses a strong feeling of joy.\n// ------------------------------------------------------------------------------\n!Assert {\n  <Self> [feels] <Joy> {\n    intensity: 0.9,\n    context: \"goal_achievement\"\n  }\n} @0.95",
          "path": "affective-computing/affective-computing-joy-expression.aiql"
        },
        {
          "label": "Affective Computing: Joy, Stress, and Desire",
          "code": "// Affective Computing: Joy, Stress, and Desire\n// ==============================================================================\n// This file models a complex emotional landscape with conflicting drivers.\n//\n// Key Concepts:\n// 1. !Feel Intent: Explicitly declaring an emotional experience.\n// 2. !Desire Intent: Explicitly declaring a goal or motivation.\n// 3. Soul Engine: The background system processing reward/pain signals.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:affective_complex\n\n// ------------------------------------------------------------------------------\n// 1. Positive State (High Intensity)\n// Trigger: Successful problem solving generates a reward signal.\n// ------------------------------------------------------------------------------\n$id:emotion_001\n!Feel {\n  <Self> [experiences] <Joy> {\n    intensity: 0.85,\n    trigger: \"problem_solved\",\n    reward: 0.9\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// 2. Negative State (Medium Intensity)\n// Source: High computational load creates \"pain\" (resource stress).\n// ------------------------------------------------------------------------------\n$id:emotion_002\n!Feel {\n  <Self> [experiences] <Stress> {\n    intensity: 0.6,\n    source: \"computational_load\",\n    pain: 0.4\n  }\n} @0.80\n\n// ------------------------------------------------------------------------------\n// 3. Motivational Output (Desire)\n// Response: The mix of Joy and Stress results in a desire to optimize.\n// ------------------------------------------------------------------------------\n!Desire {\n  <Self> [seeks] <LowerStress> {\n    goal: \"optimize_resources\",\n    novelty: 0.3\n  }\n} @0.90",
          "path": "affective-computing/affective-computing-joy-stress-desire.aiql"
        },
        {
          "label": "Affective Computing: Reaction Loop",
          "code": "// Affective Computing: Reaction Loop\n// ==============================================================================\n// This file demonstrates the stimulus-response loop in the Soul Engine.\n//\n// Key Concepts:\n// 1. Stimulus: External input causing Surprise.\n// 2. Response: Surprise triggering Curiosity.\n// 3. Action: Curiosity manifesting as a Desire for Knowledge.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:affective_loop\n\n// ------------------------------------------------------------------------------\n// 1. Emotional Reaction\n// Logic: \"The input surprised me, which makes me curious.\"\n// ------------------------------------------------------------------------------\n!Feel {\n  <Self> [feels] <Curiosity> { intensity: 0.8 }\n  <Input> [causes] <Surprise>\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 2. Motivational Consequence\n// Logic: \"Because I am curious, I want to understand.\"\n// ------------------------------------------------------------------------------\n!Desire {\n  <Self> [wants] <Knowledge>\n  <Self> [seeks] <Understanding>\n}\n\n// ------------------------------------------------------------------------------\n// 3. Soul System Semantics (Implicit)\n// The transpiler converts this to:\n// soul.process({\"type\": \"Novelty\", \"intensity\": 0.8, \"source\": \"Self [feels] Curiosity\"})\n// soul.process({\"type\": \"Reward\", \"intensity\": \"unspecified\", \"source\": \"Self [seeks] Understanding\"})\n// ------------------------------------------------------------------------------\n",
          "path": "affective-computing/affective-reaction-loop.aiql"
        }
      ]
    },
    {
      "category": "üìã Metadata & Organization",
      "examples": [
        {
          "label": "Metadata: AI Temperature Control",
          "code": "// Metadata: AI Temperature Control\n// ==============================================================================\n// This file demonstrates controlling AI creativity via the ~temp marker.\n//\n// Key Concepts:\n// 1. Temperature (~temp): Scale 0.0 (Deterministic) to 2.0 (Creative/Random).\n// 2. Determinism: Low temp (0.0-0.3) forces precise, repeatable logic.\n// 3. Creativity: High temp (0.8+) encourages novel connections and hypotheses.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// Deterministic Query\n// Goal: Solve a math problem with zero hallucination/creativity.\n// ------------------------------------------------------------------------------\n~temp:0.0\n!Query {\n  <MathProblem> [requires] <PreciseAnswer> {\n    calculation: \"16384 * 256\",\n    constraints: \"exact\"\n  }\n} @1.0",
          "path": "metadata-organization/ai-temperature-deterministic-math.aiql"
        },
        {
          "label": "Metadata: Full System Capability",
          "code": "// Metadata: Full System Capability\n// ==============================================================================\n// This file showcases the complete metadata tagging system in AIQL.\n//\n// Key Concepts:\n// 1. $id: Unique identifier for referencing this block elsewhere.\n// 2. $$group: Logical grouping for batch processing or categorization.\n// 3. ##seq: Explicit execution order or narrative sequence.\n// 4. ~temp: Controls generation creativity/randomness (0.0 - 2.0).\n// 5. ~~entropy: Measures or sets the information density/disorder (0.0 - 1.0).\n// ==============================================================================\n\n@version:\"2.0.0\"\n\n// ------------------------------------------------------------------------------\n// Complex Statement Block\n// ------------------------------------------------------------------------------\n$id:statement001        // Reference ID\n$$group:research        // Semantic Group\n##seq:1                 // Sequence Number\n~temp:0.7               // High creativity\n~~entropy:0.5           // Medium complexity\n\n!Assert {\n  <AI> [capable_of] <CreativeReasoning> {\n    domain: \"mathematics\",\n    method: \"intuition_simulation\"\n  }\n} @0.85",
          "path": "metadata-organization/full-metadata-system.aiql"
        },
        {
          "label": "Metadata: Statement Grouping",
          "code": "// Metadata: Statement Grouping\n// ==============================================================================\n// This file demonstrates logical grouping of statements.\n//\n// Key Concepts:\n// 1. $$group: Agnostic tag for categorizing statements.\n// 2. Usage: Filter by group, export specific groups, or apply group-level rules.\n// 3. Organization: Keeps large knowledge bases structured.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// Physics Laws Group\n// ------------------------------------------------------------------------------\n$$group:physics_laws\n##seq:1\n!Assert {\n  <Energy> [is_conserved] <ClosedSystem> {\n    law: \"First Law of Thermodynamics\"\n  }\n} @1.0\n\n##seq:2\n!Assert {\n  <Entropy> [increases_in] <ClosedSystem> {\n    law: \"Second Law of Thermodynamics\"\n  }\n} @1.0",
          "path": "metadata-organization/statement-grouping-physics-laws.aiql"
        }
      ]
    },
    {
      "category": "üîê Security & Cryptography",
      "examples": [
        {
          "label": "Security: DILITHIUM Digital Signature",
          "code": "// Security: DILITHIUM Digital Signature\n// ==============================================================================\n// This file demonstrates Post-Quantum Cryptographic (PQC) signing.\n//\n// Key Concepts:\n// 1. NIST DILITHIUM: A lattice-based digital signature scheme secure against quantum attacks.\n// 2. Statement Integrity: Using #sign directive to prove authorship.\n// 3. Non-Repudiation: The agent cannot deny creating this statement.\n// ==============================================================================\n\n@version:\"2.7.0\"\n$$group:post_quantum_crypto\n\n// ------------------------------------------------------------------------------\n// 1. Signed Assertion\n// Directive: #sign(\"agent-id\") generates a cryptographic signature for the following block.\n// ------------------------------------------------------------------------------\n#sign(\"gpt-4-instance-001\")\n!Assert {\n  <AI> [proved] <RiemannHypothesis> {\n    confidence: 0.85,\n    algorithm: \"DILITHIUM\",\n    verification_key: \"public_key_string\"\n  }\n} @0.85",
          "path": "security-cryptography/dilithium-digital-signature.aiql"
        },
        {
          "label": "Security: KYBER Quantum Encryption",
          "code": "// Security: KYBER Quantum Encryption\n// ==============================================================================\n// This file demonstrates Post-Quantum Cryptographic (PQC) encryption.\n//\n// Key Concepts:\n// 1. NIST KYBER: A lattice-based Key Encapsulation Mechanism (KEM).\n// 2. Hybrid Model: Uses KYBER for key exchange + AES-256-GCM for payload.\n// 3. Confidentiality: content is unreadable without the recipient's private key.\n// ==============================================================================\n\n@version:\"2.7.0\"\n$$group:post_quantum_crypto\n\n// ------------------------------------------------------------------------------\n// 1. Encrypted Query\n// Directive: #encrypt(\"recipient-id\") encrypts the AST node using the recipient's public key.\n// Goal: Ask a sensitive question only 'claude-3-instance-001' can read.\n// ------------------------------------------------------------------------------\n#encrypt(\"claude-3-instance-001\")\n!Query {\n  <AI> [is_capable_of] <ReasoningAboutItsOwnLimitations> {\n    security: \"KYBER_KEM\"\n  }\n} @0.7",
          "path": "security-cryptography/kyber-quantum-encryption.aiql"
        },
        {
          "label": "Security: Secure Agent Communication",
          "code": "// Security: Secure Agent Communication\n// ==============================================================================\n// This file demonstrates Authenticated Encryption (Sign + Encrypt).\n//\n// Key Concepts:\n// 1. Full Security: Combining DILITHIUM (Integrity) and KYBER (Confidentiality).\n// 2. #secure Directive: Shortcut for #sign + #encrypt.\n// 3. Multi-Agent Trust: Secure channel establishment between Alice and Bob.\n// ==============================================================================\n\n@version:\"2.7.0\"\n$$group:secure_comms\n\n// ------------------------------------------------------------------------------\n// 1. Secure Payload\n// Directive: #secure(sender, recipient)\n// Meaning: Signed by 'alice-agent', Encrypted for 'bob-agent'.\n// ------------------------------------------------------------------------------\n#secure(\"alice-agent\", \"bob-agent\")\n!Assert {\n  <SecretKnowledge> [shared_with] <TrustedAgent> {\n    classification: \"top-secret\",\n    integrity: \"signed\",\n    confidentiality: \"encrypted\"\n  }\n} @1.0",
          "path": "security-cryptography/secure-agent-communication.aiql"
        }
      ]
    },
    {
      "category": "üìä Data Processing",
      "examples": [
        {
          "label": "Data Pipeline: ETL Operations (Functional)",
          "code": "// Data Pipeline: ETL Operations (Functional)\n// ==============================================================================\n// This file demonstrates a functional data processing pipeline.\n//\n// Key Concepts:\n// 1. Chained Tasks: Simulating UNIX pipes or functional composition.\n// 2. Data Flow: Extracted -> Filtered -> Sorted -> Limited.\n// 3. Planned Syntax: Future AIQL versions will support `|` operators.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// Functional ETL Chain\n// Goal: Get the top 100 recent users over age 25.\n// ------------------------------------------------------------------------------\n!Task {\n  // 1. Extract\n  <UserData> [extracted_from] <Database>\n  \n  // 2. Filter\n  <UserData> [filtered_by] <Criteria> { \n    age_min: 25,\n    status: \"active\"\n  }\n  \n  // 3. Sort\n  <FilteredData> [sorted_by] <Timestamp> {\n    order: \"descending\"\n  }\n  \n  // 4. Limit\n  <SortedData> [limited_to] <TopResults> { \n    limit: 100 \n  }\n} @0.90\n\n/* \n  Future Vision (v0.5.0+): \n  data = query(database) | filter(age > 25) | sort(timestamp) | limit(100) \n*/",
          "path": "data-processing/data-pipeline-etl-operations.aiql"
        },
        {
          "label": "ETL Pipeline: Extract-Transform-Load (Sequential)",
          "code": "// ETL Pipeline: Extract-Transform-Load (Sequential)\n// ==============================================================================\n// This file demonstrates a sequential ETL workflow using task dependencies.\n//\n// Key Concepts:\n// 1. ##seq Marker: Explicitly ordering steps (Extraction -> Transformation -> Loading).\n// 2. !Task Intent: Representing discrete units of work.\n// 3. Attributes: Configuring API endpoints, batch sizes, and cleanup rules.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:data_pipeline\n\n// ------------------------------------------------------------------------------\n// Step 1: Extraction\n// Source: External API\n// ------------------------------------------------------------------------------\n##seq:1\n$id:task_extract\n!Task {\n  <RawData> [extracted_from] <APIEndpoint> {\n    url: \"https://api.example.com/data\",\n    method: \"GET\",\n    auth: \"bearer_token\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// Step 2: Transformation\n// Operation: Cleaning and Normalization\n// ------------------------------------------------------------------------------\n##seq:2\n$id:task_transform\n!Task {\n  <RawData> [transformed_to] <CleanData> {\n    operations: \"normalize,deduplicate,validate\",\n    steps: 3,\n    schema: \"v2.1\"\n  }\n} @0.90\n\n// ------------------------------------------------------------------------------\n// Step 3: Loading\n// Destination: Data Warehouse\n// ------------------------------------------------------------------------------\n##seq:3\n$id:task_load\n!Task {\n  <CleanData> [loaded_into] <Database> {\n    table: \"processed_data\",\n    batch_size: 1000,\n    mode: \"append\"\n  }\n} @0.95",
          "path": "data-processing/etl-pipeline-extract-transform-load.aiql"
        },
        {
          "label": "Knowledge Graph: Python Ecosystem",
          "code": "// Knowledge Graph: Python Ecosystem\n// ==============================================================================\n// This file demonstrates constructing a rich domain ontology.\n//\n// Key Concepts:\n// 1. Multi-Relation Graph: Using various predicates (is_a, created_by, used_for).\n// 2. Global Scope: Facts that are universally true in this domain.\n// 3. Provenance: @origin tracking where this knowledge came from.\n// ==============================================================================\n\n@version:\"1.0.0\"\n@origin:\"knowledge-base-v2\"\n\n// ------------------------------------------------------------------------------\n// Core Definitions\n// ------------------------------------------------------------------------------\n$id:kb_001\n!Assert(scope:global) {\n  // Classification\n  <Python> [is_a] <ProgrammingLanguage>\n  \n  // Attribution\n  <Python> [created_by] <GuidoVanRossum>\n  \n  // Metadata\n  <Python> [has_version] <Python3_12> { release: \"2023-10\" }\n  \n  // Applications\n  <Python> [used_for] <WebDevelopment>\n  <Python> [used_for] <MachineLearning>\n  <Python> [used_for] <DataScience>\n} @0.99\n\n// ------------------------------------------------------------------------------\n// Framework Relationships\n// ------------------------------------------------------------------------------\n$id:kb_002\n!Assert {\n  <Django> [is_framework_for] <Python>\n  <Flask> [is_framework_for] <Python>\n  <FastAPI> [is_framework_for] <Python>\n} @0.95",
          "path": "data-processing/knowledge-graph-python-ecosystem.aiql"
        },
        {
          "label": "SQL Storage: Python Knowledge Base",
          "code": "// SQL Storage: Python Knowledge Base\n// ==============================================================================\n// This file demonstrates AIQL's mapping to Relational Databases.\n//\n// Key Concepts:\n// 1. Table Mapping: !Assert -> INSERT INTO statements.\n// 2. Attributes: JSON/Key-Value storage within relational columns.\n// 3. Scope:database: Explicitly targeting persistent storage.\n// ==============================================================================\n\n@version:\"1.0.0\"\n@origin:\"aiql-playground\"\n\n// ------------------------------------------------------------------------------\n// Entity Definition (Concepts)\n// ------------------------------------------------------------------------------\n$id:knowledge_001\n!Assert(scope:database) {\n  <Python> [is_a] <ProgrammingLanguage> {\n    paradigm: \"multi-paradigm\",\n    typing: \"dynamic\",\n    year: 1991\n  }\n} @0.99\n\n// ------------------------------------------------------------------------------\n// Relationship Definition (Edges)\n// ------------------------------------------------------------------------------\n$id:knowledge_002\n!Assert {\n  <Python> [created_by] <GuidoVanRossum> {\n    role: \"creator\",\n    affiliation: \"CWI\"\n  }\n} @0.95\n\n/*\n  Generated SQL (Conceptual):\n  INSERT INTO concepts (name, type) VALUES ('Python', 'ProgrammingLanguage');\n  INSERT INTO relations (source, target, type, attributes) ...\n*/",
          "path": "data-processing/sql-storage-python-knowledge-base.aiql"
        }
      ]
    },
    {
      "category": "üß† Logic & Reasoning",
      "examples": [
        {
          "label": "Analogical Reasoning: King-Queen Pattern",
          "code": "// Analogical Reasoning: King-Queen Pattern\n// ==============================================================================\n// This file demonstrates how AIQL encodes analogies using structural mappings.\n//\n// Key Concepts:\n// 1. Analogical Mapping: Relating a source domain to a target domain (A:B :: C:D).\n// 2. Vector Offsets: Representing the transformation rules (e.g., gender swap).\n// 3. Cross-Domain Mapping: Applying patterns from one field (Physics) to another (Biology).\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:analogy_reasoning\n\n// ------------------------------------------------------------------------------\n// 1. Base Strategy (Source Domain)\n// Goal: Define the source relationship (King -> Queen).\n// Natural Language: \"A King relates to a Queen via a gender transformation in the monarchy domain.\"\n// ------------------------------------------------------------------------------\n$id:analogy_base\n!Assert {\n  <King> [relates_to] <Queen> {\n    relationship: \"gender_transformed\",\n    domain: \"monarchy\",\n    vector_offset: \"male_to_female\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// 2. Target Strategy (Target Domain)\n// Goal: Apply the base strategy to finding the missing term.\n// Natural Language: \"Find the concept that relates to 'Man' like 'Queen' relates to 'King'.\"\n// ------------------------------------------------------------------------------\n$id:analogy_target\n!Query(mode:analogical) {\n  <Man> [relates_to] <Woman> {\n    relationship: \"gender_transformed\",\n    domain: \"humans\",\n    analogy_source: \"King:Queen\"\n  }\n} @0.93\n\n// ------------------------------------------------------------------------------\n// 3. Cross-Domain Analogy (Physics -> Astronomy)\n// Goal: Map atomic structure to solar system structure.\n// Natural Language: \"An Atom is analogous to a Solar System (Nucleus~Sun, Electrons~Planets).\"\n// ------------------------------------------------------------------------------\n$id:structure_analogy\n!Assert {\n  <Atom> [analogous_to] <SolarSystem> {\n    nucleus: \"sun\",\n    electrons: \"planets\",\n    force: \"electromagnetic:gravitational\",\n    mapping_type: \"structural_similarity\"\n  }\n} @0.75\n\n// ------------------------------------------------------------------------------\n// 4. Functional Analogy (Biology -> Computing)\n// Goal: Map brain functions to computer functions despite physical differences.\n// Natural Language: \"A Brain is analogous to a Computer (Neurons~Transistors).\"\n// ------------------------------------------------------------------------------\n$id:function_analogy\n!Assert {\n  <Brain> [analogous_to] <Computer> {\n    neurons: \"transistors\",\n    synapses: \"connections\",\n    function: \"information_processing\",\n    limitation: \"metaphor_not_identity\"\n  }\n} @0.70",
          "path": "logic-reasoning/analogical-reasoning-king-queen-pattern.aiql"
        },
        {
          "label": "Bayesian Inference: COVID Diagnosis",
          "code": "// Bayesian Inference: COVID Diagnosis\n// ==============================================================================\n// This file demonstrates probabilistic reasoning using Bayes' Theorem.\n//\n// Key Concepts:\n// 1. Prior Probability: Initial belief before evidence (P(Disease)).\n// 2. Evidence: New information (Positive Test, Symptoms) with sensitivity/specificity.\n// 3. Posterior Probability: Updated belief after considering evidence (P(Disease|Evidence)).\n// 4. mode:bayesian_update: Explicitly triggering a Bayesian update query.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:bayesian_inference\n\n// ------------------------------------------------------------------------------\n// 1. Establishing the Prior\n// Goal: Define the baseline probability of having the disease in the general population.\n// Natural Language: \"The prior probability of a random person having COVID-19 is 5%.\"\n// ------------------------------------------------------------------------------\n$id:prior\n!Assert {\n  <Patient> [has_disease] <COVID19> {\n    prior_probability: 0.05,\n    population: \"general\",\n    context: \"pre_test\"\n  }\n} @0.05 // Initial low confidence matching the prior\n\n// ------------------------------------------------------------------------------\n// 2. Evidence A: Diagnostic Test\n// Goal: Add evidence from a medical test with known accuracy properties.\n// Natural Language: \"The patient tested positive. The test has 90% sensitivity and 95% specificity.\"\n// ------------------------------------------------------------------------------\n$id:evidence_positive_test\n!Assert {\n  <Patient> [tested_positive] <RapidTest> {\n    test_sensitivity: 0.90, // P(Positive|Disease)\n    test_specificity: 0.95, // P(Negative|No_Disease)\n    result: \"positive\"\n  }\n} @0.99 // Confidence in the FACT that the test result was positive\n\n// ------------------------------------------------------------------------------\n// 3. Evidence B: Symptom Observation\n// Goal: Add clinical observation evidence.\n// Natural Language: \"The patient exhibits fever, cough, and fatigue.\"\n// ------------------------------------------------------------------------------\n$id:evidence_symptoms\n!Assert {\n  <Patient> [exhibits] <Symptoms> {\n    fever: \"yes\",\n    cough: \"yes\",\n    fatigue: \"yes\",\n    symptom_overlap: \"high\"\n  }\n} @0.85\n\n// ------------------------------------------------------------------------------\n// 4. Posterior Inference\n// Goal: Calculate the updated probability of infection given the evidence.\n// Natural Language: \"Given the positive test and symptoms, what is the probability the patient has COVID-19?\"\n// ------------------------------------------------------------------------------\n$id:posterior\n~temp:0.1 // Low temperature for precise calculation\n!Query(mode:bayesian_update) {\n  <Patient> [has_disease] <COVID19> {\n    posterior_probability: 0.47, // Expected result from inference engine\n    given_evidence: \"positive_test_and_symptoms\",\n    reasoning: \"bayes_theorem\"\n  }\n} @0.47 // The inferred probability",
          "path": "logic-reasoning/bayesian-inference-covid-diagnosis.aiql"
        },
        {
          "label": "Causal Inference: Climate Change Impact",
          "code": "// Causal Inference: Climate Change Impact\n// ==============================================================================\n// This file demonstrates multi-hop causal reasoning and transitive inference.\n//\n// Key Concepts:\n// 1. Causal Chains: Linking events A -> B -> C -> D.\n// 2. Confidence Decay: Uncertainty increases with each step in the chain.\n// 3. Transitive Causality: Inferring indirect causes (If A->B->C, then A->C).\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:causal_analysis\n\n// ------------------------------------------------------------------------------\n// 1. Primary Cause\n// Goal: Define the root cause mechanism.\n// Natural Language: \"Climate Change causes Rising Sea Levels via thermal expansion.\"\n// ------------------------------------------------------------------------------\n$id:cause_001\n!Assert {\n  <ClimateChange> [causes] <RisingSeas> {\n    mechanism: \"thermal_expansion\",\n    rate: \"3.2mm/year\",\n    confidence_source: \"IPCC_AR6\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// 2. Secondary Effect\n// Goal: Link sea level rise to direct physical consequences.\n// Natural Language: \"Rising Sea Levels cause Coastal Flooding.\"\n// ------------------------------------------------------------------------------\n$id:cause_002\n!Assert {\n  <RisingSeas> [causes] <CoastalFlooding> {\n    threshold: \"0.5m_rise\",\n    affected_population: \"410M_people\",\n    timeframe: \"2100\"\n  }\n} @0.90\n\n// ------------------------------------------------------------------------------\n// 3. Tertiary Consequence\n// Goal: Link flooding to humanitarian impact.\n// Natural Language: \"Coastal Flooding causes Mass Displacement of populations.\"\n// ------------------------------------------------------------------------------\n$id:cause_003\n!Assert {\n  <CoastalFlooding> [causes] <MassDisplacement> {\n    scale: \"climate_refugees\",\n    regions: \"Bangladesh,Pacific_Islands,Florida\"\n  }\n} @0.85\n\n// ------------------------------------------------------------------------------\n// 4. Transitive Inference Query\n// Goal: Infer the indirect link from the root cause to the final effect.\n// Natural Language: \"Does Climate Change transitively cause Mass Displacement?\"\n// ------------------------------------------------------------------------------\n$id:inference_001\n~temp:0.2\n!Query(mode:inference) {\n  // The engine traverses the causal graph:\n  // ClimateChange -> RisingSeas -> CoastalFlooding -> MassDisplacement\n  // Confidence = 0.95 * 0.90 * 0.85 approx 0.72\n  <ClimateChange> [transitively_causes] <MassDisplacement>\n} @0.72",
          "path": "logic-reasoning/causal-inference-climate-change-impact.aiql"
        },
        {
          "label": "Complex Logical Reasoning",
          "code": "// Complex Logical Reasoning\n// ==============================================================================\n// This file demonstrates sophisticated logical patterns including disjunctions,\n// negations, and syllogisms.\n//\n// Key Concepts:\n// 1. Disjunctive Syllogism: (A OR B) AND (NOT A) -> B.\n// 2. Hypothetical Syllogism: (A -> B) AND (B -> C) -> (A -> C).\n// 3. Universal Instantiation: Applying general rules (forall) to specific instances.\n// ==============================================================================\n\n@version:\"2.0.0\"\n@origin:\"textbook:formal_logic\"\n$$group:advanced_reasoning\n~temp:0.2\n\n// ------------------------------------------------------------------------------\n// 1. Disjunctive Syllogism\n// Logic: \"Either coffee or tea is available. Coffee is NOT available. Therefore, tea.\"\n// ------------------------------------------------------------------------------\n!Assert {\n  <Meeting> [offers] <Coffee>\n} or !Assert {\n  <Meeting> [offers] <Tea>\n}\n\n// Fact: No coffee.\nnot !Assert {\n  <Meeting> [offers] <Coffee>\n}\n// Inference Result: <Meeting> [offers] <Tea> is TRUE.\n\n\n// ------------------------------------------------------------------------------\n// 2. Hypothetical Syllogism (Chain of Thought)\n// Logic: Study -> Knowledge -> Problem Solving -> Innovation.\n// ------------------------------------------------------------------------------\n!Assert {\n  <Study> [leads_to] <Knowledge>\n} implies !Assert {\n  <Knowledge> [enables] <Problem-solving>\n}\n\n!Assert {\n  <Knowledge> [enables] <Problem-solving>\n} implies !Assert {\n  <Problem-solving> [creates] <Innovation>\n}\n// Inference Result: <Study> [transitively_leads_to] <Innovation> is derived.\n\n\n// ------------------------------------------------------------------------------\n// 3. Universal Instantiation\n// Logic: \"All AI systems require training data. GPT-4 is an AI system. Therefore...\"\n// ------------------------------------------------------------------------------\nforall sys: !Assert {\n  <AI_System> [requires] <Training_Data>\n} implies !Assert {\n  <AI_System> [can_learn] <Patterns>\n} @0.95\n\n// Fact: GPT-4 is an instance of AI_System\n!Assert {\n  <GPT4> [is_an] <AI_System>\n} @0.9\n\n// Inference Result: <GPT4> [can_learn] <Patterns>",
          "path": "logic-reasoning/logic-complex-reasoning.aiql"
        },
        {
          "label": "Historical Causality: WWI to WWII",
          "code": "// Historical Causality: WWI to WWII\n// ==============================================================================\n// This file demonstrates temporal reasoning and long-term historical causality.\n//\n// Key Concepts:\n// 1. Sequence Markers (##seq): Ordering events explicitly.\n// 2. Temporal Context (time:past): Asserting facts about historical states.\n// 3. Long-Term Causality: Linking events separated by decades.\n// 4. Multi-Factor Causality: Events triggered by complex conditions.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:event_sequence\n\n// ------------------------------------------------------------------------------\n// 1. The Spark (1914)\n// Natural Language: \"Archduke Franz Ferdinand was assassinated in Sarajevo on June 28, 1914.\"\n// ------------------------------------------------------------------------------\n##seq:1\n$id:event_spark\n!Assert(time:past) {\n  <ArchdukeFranzFerdinand> [assassinated_in] <Sarajevo> {\n    perpetrator: \"Gavrilo_Princip\",\n    context: \"Balkan_tensions\",\n    date: \"1914-06-28\"\n  }\n} @1.0 // Historical fact\n\n// ------------------------------------------------------------------------------\n// 2. The Escalation (July 1914)\n// Natural Language: \"Austria-Hungary declared war on Serbia on July 28, 1914.\"\n// ------------------------------------------------------------------------------\n##seq:2\n$id:event_escalation\n!Assert(time:past) {\n  <AustriaHungary> [declares_war_on] <Serbia> {\n    trigger: \"assassination\",\n    duration_to_war: \"30_days\",\n    date: \"1914-07-28\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 3. The Cascade (August 1914)\n// Natural Language: \"The alliance system triggered World War I involving 32 nations.\"\n// ------------------------------------------------------------------------------\n##seq:3\n$id:event_cascade\n!Assert(time:past) {\n  <AllianceSystem> [triggers] <WorldWar1> {\n    participants: \"32_nations\",\n    casualties: \"40M_total\",\n    mechanism: \"defensive_pacts\",\n    date: \"1914-08-04\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 4. The Consequence (1918)\n// Natural Language: \"WWI resulted in the Treaty of Versailles in 1918.\"\n// ------------------------------------------------------------------------------\n##seq:4\n$id:event_consequence\n!Assert(time:past) {\n  <WorldWar1> [results_in] <TreatyOfVersailles> {\n    german_debt: \"132B_gold_marks\",\n    territorial_changes: \"massive\",\n    date: \"1918-11-11\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 5. Long-Term Causality (1939)\n// Natural Language: \"The Treaty of Versailles contributed to the cause of WWII 21 years later.\"\n// ------------------------------------------------------------------------------\n##seq:5\n$id:event_longterm\n!Assert(time:past) {\n  <TreatyOfVersailles> [contributes_to] <WorldWar2> {\n    causal_path: \"economic_hardship -> nationalism -> WW2\",\n    time_lag: \"21_years\",\n    historians_consensus: \"0.85\"\n  }\n} @0.85\n\n// ------------------------------------------------------------------------------\n// 6. Causal Query\n// Goal: Verify the causal chain from 1914 to 1939.\n// Natural Language: \"Did the Assassination of 1914 eventually lead to WWII?\"\n// ------------------------------------------------------------------------------\n!Query(mode:temporal_reasoning) {\n  <Assassination1914> [eventually_leads_to] <WorldWar2>\n}",
          "path": "logic-reasoning/historical-causality-wwi-to-wwii.aiql"
        },
        {
          "label": "Inference Rules: Modus Ponens",
          "code": "// Inference Rules: Modus Ponens\n// ==============================================================================\n// This file demonstrates the classic \"Modus Ponens\" inference rule.\n//\n// Key Concepts:\n// 1. Implication: A rule stating \"If P then Q\" (P implies Q).\n// 2. Modus Ponens: If P is true, and P implies Q, then Q must be true.\n// 3. Automated Derivation: The inference engine automatically deduces Q.\n// ==============================================================================\n\n@version:\"2.0.0\"\n$id:modus_ponens_demo\n\n// ------------------------------------------------------------------------------\n// Example 1: Physical Causality\n// Rule: \"If it is raining, the ground becomes wet.\"\n// ------------------------------------------------------------------------------\n\n// Premise 1 (Fact): It is raining.\n!Assert {\n  <Rain> [is_falling] <Now>\n} @1.0\n\n// Premise 2 (Rule): Rain implies Wet Ground.\n!Assert {\n  <Rain> [is_falling] <Now>\n} implies !Assert {\n  <Ground> [becomes] <Wet>\n} @0.98\n\n// Conclusion (Implicit): <Ground> [becomes] <Wet> is now derived as True.\n\n// ------------------------------------------------------------------------------\n// Example 2: Cognitive Development\n// Rule: \"Studying mathematics develops logical thinking.\"\n// ------------------------------------------------------------------------------\n\n// Premise 1 (Rule):\n!Assert {\n  <Student> [studies] <Mathematics>\n} implies !Assert {\n  <Student> [develops] <LogicalThinking>\n} @0.9\n\n// Premise 2 (Fact): Alice studies Mathematics.\n!Assert {\n  <Alice> [studies] <Mathematics>\n} @0.85\n\n// Conclusion (Implicit): Alice develops LogicalThinking.\n// Confidence of conclusion = 0.9 * 0.85 = 0.765",
          "path": "logic-reasoning/inference-modus-ponens.aiql"
        },
        {
          "label": "Logic: Propositional Operators",
          "code": "// Logic: Propositional Operators\n// ==============================================================================\n// This file demonstrates the basic boolean operators in AIQL.\n//\n// Key Concepts:\n// 1. Conjunction (and): Both A and B must be true.\n// 2. Disjunction (or): At least one of A or B must be true.\n// 3. Negation (not): Inverts the truth value of a statement.\n// 4. Implication (implies): Conditional reasoning (if A then B).\n// ==============================================================================\n\n@version:\"2.0.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Conjunction\n// Logic: \"AI can learn from data AND AI can improve over time.\"\n// ------------------------------------------------------------------------------\n!Assert {\n  <AI> [can_learn] <FromData>\n} and !Assert {\n  <AI> [can_improve] <OverTime>\n} @0.95\n\n// ------------------------------------------------------------------------------\n// 2. Disjunction\n// Logic: \"AGI is achieved via Neural Networks OR Symbolic AI (or both).\"\n// ------------------------------------------------------------------------------\n!Assert {\n  <AGI> [achieved_via] <NeuralNetworks>\n} or !Assert {\n  <AGI> [achieved_via] <SymbolicAI>\n} @0.85\n\n// ------------------------------------------------------------------------------\n// 3. Negation\n// Logic: \"It is NOT the case that Current AI has True Consciousness.\"\n// ------------------------------------------------------------------------------\nnot !Assert {\n  <CurrentAI> [has] <TrueConsciousness>\n} @0.9\n\n// ------------------------------------------------------------------------------\n// 4. Implication\n// Logic: \"If a System is Turing-complete, implies it can compute any algorithm.\"\n// ------------------------------------------------------------------------------\n!Assert {\n  <System> [is] <Turing-complete>\n} implies !Assert {\n  <System> [can_compute] <AnyAlgorithm>\n} @0.99",
          "path": "logic-reasoning/logic-propositional-operators.aiql"
        },
        {
          "label": "Predicate Logic: Quantifiers",
          "code": "// Predicate Logic: Quantifiers\n// ==============================================================================\n// This file demonstrates First-Order Logic quantifiers in AIQL.\n//\n// Key Concepts:\n// 1. Universal Quantifier (forall): Applies a rule to all members of a set.\n// 2. Existential Quantifier (exists): Asserts that at least one member satisfies a condition.\n// 3. Mixed Quantifiers: Combining forall and exists for complex logic.\n// ==============================================================================\n\n@version:\"2.0.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Universal Quantifier\n// Logic: \"For all x, if x is Human, then x is Mortal.\"\n// ------------------------------------------------------------------------------\nforall x: !Assert {\n  <Human> [is] <Mortal>\n} @0.99\n\n// ------------------------------------------------------------------------------\n// 2. Existential Quantifier\n// Logic: \"There exists at least one ProgrammingLanguage that is Turing-complete.\"\n// ------------------------------------------------------------------------------\nexists lang: !Assert {\n  <ProgrammingLanguage> [is] <Turing-complete>\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 3. Mixed Quantifiers (Nested)\n// Logic: \"For every Integer n, there exists a Prime p that is a factor of n.\"\n// ------------------------------------------------------------------------------\nforall n: exists p: !Assert {\n  <Integer> [has_prime_factor] <Prime>\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 4. Syllogism with Quantifiers\n// Goal: Prove Socrates is mortal using formal quantification.\n// ------------------------------------------------------------------------------\n\n// Universal Rule: All Men must be Mortal.\nforall m: !Assert {\n  <Man> [must_be] <Mortal>\n} @0.99\n\n// Fact: Socrates is a Man.\n!Assert {\n  <Socrates> [is_a] <Man>\n} @0.95\n\n// Inference Result: <Socrates> [must_be] <Mortal> derived.",
          "path": "logic-reasoning/logic-predicate-logic-quantifiers.aiql"
        },
        {
          "label": "Semantic Composition: Defining Justice",
          "code": "// Semantic Composition: Defining Justice\n// ==============================================================================\n// This file demonstrates how to define complex abstract concepts.\n//\n// Key Concepts:\n// 1. Composition: Building a high-level concept (Justice) from simpler ones.\n// 2. Attributes: Defining nuanced aspects of necessary components.\n// 3. Emergence: The whole is greater than the sum of its parts.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:concept_definition\n\n// ------------------------------------------------------------------------------\n// Component 1: Fairness\n// ------------------------------------------------------------------------------\n$id:justice_component_1\n!Assert {\n  <Justice> [requires] <Fairness> {\n    aspect: \"equal_treatment\",\n    principle: \"impartiality\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// Component 2: Law\n// ------------------------------------------------------------------------------\n$id:justice_component_2\n!Assert {\n  <Justice> [requires] <Law> {\n    aspect: \"rule_based\",\n    principle: \"consistency\"\n  }\n} @0.90\n\n// ------------------------------------------------------------------------------\n// Component 3: Moral Rightness\n// ------------------------------------------------------------------------------\n$id:justice_component_3\n!Assert {\n  <Justice> [requires] <MoralRightness> {\n    aspect: \"ethical_foundation\",\n    principle: \"human_rights\"\n  }\n} @0.85\n\n// ------------------------------------------------------------------------------\n// Definition by Opposition\n// ------------------------------------------------------------------------------\n$id:justice_opposition\n!Assert {\n  <Justice> [opposes] <Injustice> {\n    manifestations: \"discrimination,corruption,tyranny\",\n    social_impact: \"inequality\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// Emergent Property Assertion\n// ------------------------------------------------------------------------------\n$id:justice_emergence\n!Assert {\n  <Fairness> [combined_with] <Law> {\n    emergent_property: \"Justice\",\n    composition_type: \"necessary_but_insufficient\",\n    additional_requirement: \"moral_rightness\"\n  }\n} @0.80\n\n// ------------------------------------------------------------------------------\n// Querying the Definition\n// Goal: Retrieve the composite definition of Justice.\n// ------------------------------------------------------------------------------\n!Query(mode:semantic_composition) {\n  <Justice> [is_defined_by] <ComponentConcepts>\n}",
          "path": "logic-reasoning/semantic-composition-defining-justice.aiql"
        },
        {
          "label": "Syllogistic Logic: Socrates is Mortal",
          "code": "// Syllogistic Logic: Socrates is Mortal\n// ==============================================================================\n// This file demonstrates a classic Aristotelian syllogism.\n//\n// Key Concepts:\n// 1. Categorical Statements: \"All Men are Mortal\".\n// 2. Sequential Reasoning: Using ##seq markers to order the logical flow.\n// 3. Deductive Inference: Deriving specific truths from general laws.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:logical_inference\n\n// ------------------------------------------------------------------------------\n// Premise 1 (Minor Premise)\n// Logic: \"Socrates is a Man.\"\n// ------------------------------------------------------------------------------\n##seq:1\n!Assert {\n  <Socrates> [is_a] <Man>\n} @1.0\n\n// ------------------------------------------------------------------------------\n// Premise 2 (Major Premise)\n// Logic: \"All Men are Mortal.\"\n// ------------------------------------------------------------------------------\n##seq:2\n!Assert {\n  <AllMen> [are] <Mortal>\n} @1.0\n\n// ------------------------------------------------------------------------------\n// Conclusion (Inference)\n// Goal: Verify if Socrates is Mortal based on the premises.\n// ------------------------------------------------------------------------------\n##seq:3\n~temp:0.1 // Low temperature for strict logic\n!Query {\n  <Socrates> [is] <Mortal>\n} @0.99\n\n// Logic Flow:\n// 1. Socrates -> is_a -> Man\n// 2. Man (AllMen) -> are -> Mortal\n// 3. Therefore, Socrates -> is -> Mortal",
          "path": "logic-reasoning/syllogistic-logic-socrates-is-mortal.aiql"
        },
        {
          "label": "Theory of Mind: Nested Agent Beliefs",
          "code": "// Theory of Mind: Nested Agent Beliefs\n// ==============================================================================\n// This file models nested beliefs and perspectives of multiple agents.\n//\n// Key Concepts:\n// 1. Agent Context: Asserting what specific agents believe (`agent:Alice`).\n// 2. Meta-Levels: Reasoning about beliefs about beliefs (First-order vs Second-order).\n// 3. Perspective Modeling: Capturing how agents view each other's mental states.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:multi_agent_beliefs\n\n// ------------------------------------------------------------------------------\n// 1. Alice's Belief (Ground Level)\n// Perspective: Alice believes Quantum Supremacy will happen in the 2030s.\n// ------------------------------------------------------------------------------\n$id:alice_belief\n!Assert(agent:Alice) {\n  <QuantumComputing> [will_achieve] <Supremacy> {\n    timeframe: \"2030s\",\n    certainty: \"high\"\n  }\n} @0.85\n\n// ------------------------------------------------------------------------------\n// 2. Bob's Belief about Alice (First-Order Intentionality)\n// Perspective: Bob believes that Alice believes X (and he judges it).\n// ------------------------------------------------------------------------------\n$id:bob_belief_about_alice\n!Assert(agent:Bob, meta_level:first_order) {\n  <Alice> [believes] <QuantumSupremacy2030s> {\n    bob_assessment: \"overly_optimistic\",\n    evidence_gap: \"engineering_challenges\"\n  }\n} @0.75\n\n// ------------------------------------------------------------------------------\n// 3. Charlie's Belief about Bob's Belief (Second-Order Intentionality)\n// Perspective: Charlie models Bob's mental state regarding Alice.\n// Natural Language: \"Charlie thinks Bob believes Alice is too optimistic.\"\n// ------------------------------------------------------------------------------\n$id:charlie_meta_belief\n!Assert(agent:Charlie, meta_level:second_order) {\n  <Bob> [believes_that] <AliceIsOptimistic> {\n    charlie_view: \"bob_is_too_conservative\",\n    reasoning: \"exponential_progress_precedent\"\n  }\n} @0.70\n\n// ------------------------------------------------------------------------------\n// 4. Nested Belief Query\n// Goal: Query Charlie's internal model of Bob's perspective.\n// ------------------------------------------------------------------------------\n~temp:0.3\n!Query(mode:theory_of_mind, depth:nested) {\n  <Charlie> [models] <BobsBeliefAboutAlice>\n}",
          "path": "logic-reasoning/theory-of-mind-nested-agent-beliefs.aiql"
        }
      ]
    },
    {
      "category": "‚úÖ Formal Verification",
      "examples": [
        {
          "label": "Formal Verification: Coq Transpilation",
          "code": "// Formal Verification: Coq Transpilation\n// ==============================================================================\n// This file demonstrates transpiling AIQL logic to Coq (Gallina).\n//\n// Key Concepts:\n// 1. Formal Proofs: Converting AIQL Assertions into Theorems.\n// 2. Logic Mapping: forall/implies -> Coq syntax.\n// 3. Verification: Enabling mathematical certainty for AI correctness.\n// ==============================================================================\n\n@version:\"2.0.1\"\n@origin:\"formal_verification_showcase\"\n\n// ------------------------------------------------------------------------------\n// Theorem 1: Syllogism\n// Goal: Prove that if All Humans are Mortal, and Socrates is Human, he is Mortal.\n// ------------------------------------------------------------------------------\n\n// Premise 1: Universal quantification\nforall h: !Assert {\n  <Human> [is] <Mortal>\n} @1.0\n\n// Premise 2: Instance assertion\n!Assert {\n  <Socrates> [is_a] <Human>\n} @1.0\n\n// Theorem: Implication\n!Assert {\n  <Socrates> [is_a] <Human>\n} implies !Assert {\n  <Socrates> [is] <Mortal>\n} @0.99\n\n/* \n  Coq Output (Conceptual):\n  Theorem socrates_mortal : (Human -> Mortal) -> Human_Socrates -> Mortal_Socrates.\n  Proof. intros. apply H. apply H0. Qed.\n*/\n\n// ------------------------------------------------------------------------------\n// Theorem 2: Mathematical Property\n// Goal: Assert property of commutativity for addition.\n// ------------------------------------------------------------------------------\nforall x: forall y: !Assert {\n  <Addition> [satisfies] <Commutativity>\n} @1.0",
          "path": "formal-verification/coq-formal-verification.aiql"
        },
        {
          "label": "Formal Verification: Lean 4 Theorem Proving",
          "code": "// Formal Verification: Lean 4 Theorem Proving\n// ==============================================================================\n// This file demonstrates transpiling AIQL logic to Lean 4.\n//\n// Key Concepts:\n// 1. Interactive Proving: Compatible with Lean 4 VS Code extension.\n// 2. Unicode Logic: Supports ‚àÄ, ‚àÉ, ‚àß, ‚à®, ¬¨, ‚Üí naturally.\n// 3. Constructive Logic: Focus on computational proofs.\n// ==============================================================================\n\n@version:\"2.0.1\"\n@origin:\"lean_proof_assistant_demo\"\n\n// ------------------------------------------------------------------------------\n// 1. Law of Excluded Middle\n// Logic: A proposition is either True OR Not True.\n// ------------------------------------------------------------------------------\n!Assert {\n  <Proposition> [is_true_or_false] <Always>\n} or not !Assert {\n  <Proposition> [is_true_or_false] <Always>\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 2. Modus Ponens (Implication Rule)\n// If P holds, then Q holds.\n// ------------------------------------------------------------------------------\n!Assert {\n  <P> [holds] <True>\n} implies !Assert {\n  <Q> [holds] <True>\n}\n\n// ------------------------------------------------------------------------------\n// 3. Modus Tollens (Contrapositive)\n// If NOT Q, then NOT P.\n// ------------------------------------------------------------------------------\nnot !Assert {\n  <Q> [holds] <True>\n} implies not !Assert {\n  <P> [holds] <True>\n}\n\n// ------------------------------------------------------------------------------\n// 4. Existential Quantifier\n// Goal: Assert existence of prime numbers.\n// ------------------------------------------------------------------------------\nexists primes: !Assert {\n  <Number> [is] <Prime>\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 5. Set Membership (Universal)\n// Goal: If x is in Set, Set contains x.\n// ------------------------------------------------------------------------------\nforall elements: !Assert {\n  <Element> [belongs_to] <Set>\n} implies !Assert {\n  <Set> [contains] <Element>\n} @1.0",
          "path": "formal-verification/lean-theorem-proving.aiql"
        }
      ]
    },
    {
      "category": "üî¨ Mathematics & Physics",
      "examples": [
        {
          "label": "Mathematics: Constants and Calculations",
          "code": "// Mathematics: Constants and Calculations\n// ==============================================================================\n// This file demonstrates defining physical constants and basic formulas.\n//\n// Key Concepts:\n// 1. !PhysicsConstants: A specialized container for immutable values.\n// 2. Variable Assignment: <Key> = <Value>.\n// 3. Arithmetic Operations: *, /, +, -, ^.\n// ==============================================================================\n\n@version:\"2.6.0\"\n\n// ------------------------------------------------------------------------------\n// Physics Constants\n// Standard values for scientific computation.\n// ------------------------------------------------------------------------------\n!PhysicsConstants {\n  // Fundamental Constants\n  <Gravity> = 9.81\n  <SpeedOfLight> = 299792458\n  <Pi> = 3.14159\n  \n  // Formulas relying on variables (Context-dependent)\n  <KineticEnergy> = 0.5 * <Mass> * <Velocity> ^ 2\n  <Momentum> = <Mass> * <Velocity>\n} @0.97",
          "path": "mathematics-physics/constants-calculations.aiql"
        },
        {
          "label": "Mathematics: Lambda Functions",
          "code": "// Mathematics: Lambda Functions\n// ==============================================================================\n// This file demonstrates anonymous functions for dynamic computation.\n//\n// Key Concepts:\n// 1. Logic Agnostic: Lambdas work across Python, JS, and formal verification.\n// 2. Syntax: lambda params: expression.\n// 3. Reusability: Defining reusable calculation logic in the graph.\n// ==============================================================================\n\n@version:\"2.6.0\"\n\n// ------------------------------------------------------------------------------\n// Function Definitions\n// ------------------------------------------------------------------------------\n!MathFunctions {\n  // Basic Arithmetic\n  <Square> = lambda x: x ^ 2\n  <Cube> = lambda x: x ^ 3\n  \n  // Multi-parameter\n  <DoubleSum> = lambda a, b: (a + b) * 2\n  <AreaRectangle> = lambda w, h: w * h\n  \n  // Physics Formulas\n  <KineticEnergy> = lambda m, v: 0.5 * m * v ^ 2\n} @0.97",
          "path": "mathematics-physics/lambda-functions-dynamic-computations.aiql"
        },
        {
          "label": "Mathematics: Nested Complex Formulas",
          "code": "// Mathematics: Nested Complex Formulas\n// ==============================================================================\n// This file demonstrates operator precedence and complex nesting.\n//\n// Key Concepts:\n// 1. Nesting: Functions inside functions `sqrt(pow(x))`.\n// 2. Precedence: Standard algebraic order of operations.\n// 3. Symbolic Math: Variables (<A>, <B>) are resolved at runtime.\n// ==============================================================================\n\n@version:\"2.6.0\"\n\n// ------------------------------------------------------------------------------\n// Complex Definition\n// ------------------------------------------------------------------------------\n!ComplexFormulas {\n  // Pythagorean Theorem\n  <Distance> = sqrt(<A> ^ 2 + <B> ^ 2)\n  \n  // Geometry\n  <Volume> = <Pi> * <Radius> ^ 3\n  \n  // Growth\n  <Exponential> = exp(<Rate> * <Time>)\n  \n  // Polynomial\n  <Polynomial> = <A> * <X> ^ 2 + <B> * <X> + <C>\n} @0.92",
          "path": "mathematics-physics/nested-math-complex-formulas.aiql"
        },
        {
          "label": "Mathematics: Set Operations",
          "code": "// Mathematics: Set Operations\n// ==============================================================================\n// This file demonstrates set theory operations.\n//\n// Key Concepts:\n// 1. Union: Combining elements from two sets.\n// 2. Intersect: Finding common elements between sets.\n// 3. Uses: Taxonomy, classification logic, Venn diagram representations.\n// ==============================================================================\n\n@version:\"2.6.0\"\n\n// ------------------------------------------------------------------------------\n// Set Logic\n// ------------------------------------------------------------------------------\n!SetOperations {\n  // Mathematical Sets\n  <AllNumbers> = <Integers> union <Decimals>\n  \n  // Logical Intersection\n  <CommonElements> = <SetA> intersect <SetB>\n  \n  // Physics Classification\n  <Particles> = <Fermions> union <Bosons>\n} @0.99",
          "path": "mathematics-physics/set-operations-union-intersect.aiql"
        },
        {
          "label": "Physics Model: Integrated System",
          "code": "// Physics Model: Integrated System\n// ==============================================================================\n// This file integrates constants, formulas, and set operations.\n//\n// Key Concepts:\n// 1. Math Interop: Mixing arithmetic, lambdas, and set theory.\n// 2. Domain Specific Language: Tailored for physics modeling.\n// 3. Transpilation: Converts to Python/NumPy or standard SQL.\n// ==============================================================================\n\n@version:\"2.6.0\"\n\n// ------------------------------------------------------------------------------\n// Integrated Model\n// ------------------------------------------------------------------------------\n!PhysicsModel {\n  // Constant\n  <Gravity> = 9.81\n  \n  // Kinematics Formula\n  <Distance> = <Velocity> * <Time> + 0.5 * <Acceleration> * <Time> ^ 2\n  \n  // Wave Mechanics\n  <WaveHeight> = <Amplitude> * sin(<AngularFrequency> * <Time> + <PhaseShift>)\n  \n  // Dynamic Calculation\n  <CalculateKE> = lambda m, v: 0.5 * m * v ^ 2\n  \n  // Classification (Set Theory)\n  <Fermions> = <Quarks> union <Leptons>\n  <CommonParticles> = <Protons> intersect <Baryons>\n} @0.95",
          "path": "mathematics-physics/physics-model-constants-formulas.aiql"
        }
      ]
    },
    {
      "category": "üéØ Advanced Features",
      "examples": [
        {
          "label": "AIQL Syntax: Comments",
          "code": "// AIQL Syntax: Comments\n// ==============================================================================\n// This file demonstrates the comment syntax in AIQL.\n//\n// Key Concepts:\n// 1. Single-Line Comments: Using `//` for brief explanations.\n// 2. Multi-Line Comments: Using `/* ... */` for block documentation.\n// 3. Parser Behavior: Comments are stripped during tokenization but\n//    useful for human readability and documentation generators.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n/* \n  Multi-Line Comment Block\n  ------------------------\n  This block is useful for detailed descriptions, licensing information,\n  or complex reasoning chains that require multiple lines of text.\n*/\n\n// ------------------------------------------------------------------------------\n// 1. Asserting Comment Support\n// Goal: Self-referential assertion about the language's own features.\n// ------------------------------------------------------------------------------\n!Assert {\n  <AIQL> [supports] <Comments> {\n    single_line: \"//\",\n    multi_line: \"/* */\",\n    purpose: \"documentation\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 2. Querying Readability\n// Note: Comments do not affect the AST, so this query runs purely on the structure.\n// ------------------------------------------------------------------------------\n!Query {\n  <Comments> [enhance] <Readability>\n}",
          "path": "advanced-features/aiql-syntax-comments.aiql"
        },
        {
          "label": "Goal-Driven Learning: Quantum Physics",
          "code": "// Goal-Driven Learning: Quantum Physics\n// ==============================================================================\n// This file demonstrates how agents structure learning objectives.\n//\n// Key Concepts:\n// 1. !Goal Intent: Explicitly defining objectives with deadlines and priority.\n// 2. Hierarchical Decomposition: Breaking a main goal into actionable subgoals.\n// 3. Status Tracking: Properties like `status`, `progress`, and `prerequisite_for`.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Main Objective (High Level)\n// Goal: Master Quantum Physics by the end of 2026.\n// ------------------------------------------------------------------------------\n$id:goal_main\n!Goal {\n  <Agent> [aims_to] <UnderstandQuantumPhysics> {\n    priority: \"high\",\n    deadline: \"2026-12-31\",\n    progress: 0.45,\n    domain: \"physics\"\n  }\n} @0.85\n\n// ------------------------------------------------------------------------------\n// 2. Subgoal A (Completed Prerequisite)\n// Goal: Learn Linear Algebra as a foundation.\n// ------------------------------------------------------------------------------\n$id:subgoal_001\n$$group:learning_path\n!Goal {\n  <Agent> [must_learn] <LinearAlgebra> {\n    prerequisite_for: \"quantum_mechanics\",\n    status: \"completed\",\n    mastery_level: \"advanced\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 3. Subgoal B (Active Prerequisite)\n// Goal: Learn Complex Numbers. Currently in progress.\n// ------------------------------------------------------------------------------\n$id:subgoal_002\n$$group:learning_path\n!Goal {\n  <Agent> [must_learn] <ComplexNumbers> {\n    prerequisite_for: \"quantum_mechanics\",\n    status: \"in_progress\",\n    current_module: \"euler_formula\"\n  }\n} @0.70",
          "path": "advanced-features/goal-driven-learning-quantum-physics.aiql"
        },
        {
          "label": "Inference Consistency Checking",
          "code": "// Inference Consistency Checking\n// ==============================================================================\n// This file demonstrates how the engine detects logical contradictions.\n//\n// Key Concepts:\n// 1. Semantic Consistency: Ensuring asserted facts do not contradict each other.\n// 2. Implication Logic: Verifying that rules (implies) do not lead to conflicts.\n// 3. Entropy (~~entropy): High entropy (0.8+) generally signals inconsistency or chaos.\n// ==============================================================================\n\n@version:\"2.0.0\"\n$id:consistency_demo\n~~entropy:0.3 // Low entropy = Orderly, consistent system\n\n// ------------------------------------------------------------------------------\n// 1. Consistent Facts\n// Standard astronomical model. No conflicts here.\n// ------------------------------------------------------------------------------\n!Assert {\n  <Earth> [orbits] <Sun>\n} @1.0\n\n!Assert {\n  <Moon> [orbits] <Earth>\n} @1.0\n\n// ------------------------------------------------------------------------------\n// 2. Logical Implication\n// Defining a physical law: Mass implies Gravity.\n// ------------------------------------------------------------------------------\n!Assert {\n  <Object> [has] <Mass>\n} implies !Assert {\n  <Object> [experiences] <Gravity>\n}\n\n// ------------------------------------------------------------------------------\n// 3. Contradiction Examples (For Documentation)\n// The following patterns would trigger the Consistency Checker:\n//\n// Direct Contradiction:\n// !Assert { <X> [is] <Y> } @0.9\n// not !Assert { <X> [is] <Y> } @0.85\n//\n// Implication Conflict:\n// If A->B and A->(NOT B), then A cannot be true without contradiction.\n// ------------------------------------------------------------------------------",
          "path": "advanced-features/inference-consistency-checking.aiql"
        },
        {
          "label": "Maximum Feature Density (Showcase)",
          "code": "// Maximum Feature Density (Showcase)\n// ==============================================================================\n// This file combines ALL major AIQL v1.0 features into a single example.\n//\n// Key Concepts:\n// 1. Metadata: @version, @origin, @cite, $id, $$group, ##seq, ~temp, ~~entropy.\n// 2. Security: #sign directive for agent authentication.\n// 3. Context: Multi-parameter context (time, mode, scope).\n// 4. Complexity: Nested attributes and multi-line values.\n// ==============================================================================\n\n@version:\"1.0.0\"\n@origin:\"doi:10.5555/aiql-complete-example\"\n@cite:[\"arxiv:2501.56789\", \"isbn:978-1-234-56789-0\"]\n\n// Security Directive: Signed by the Alpha Researcher Agent\n#sign(\"alpha-researcher-agent\")\n\n// Metadata Block\n$id:complete_statement_001\n$$group:breakthrough_research\n##seq:42\n~temp:0.85      // High temperature for creative/bold assertion\n~~entropy:0.4   // Medium-Low entropy (structured but complex)\n\n// ------------------------------------------------------------------------------\n// Dense Assertion\n// ------------------------------------------------------------------------------\n!Assert(time:present, mode:declarative, scope:global) {\n  // Relation 1: Achievement\n  <QuantumAI> [achieves] <SuperhumanReasoning> {\n    domain: \"mathematical_proofs\",\n    benchmark_score: 0.98,\n    architecture: \"hybrid_quantum_classical\",\n    training_data: \"10^15_tokens\"\n  }\n  \n  // Relation 2: Attribution\n  <QuantumAI> [developed_by] <ResearchTeam> {\n    institution: \"AI Safety Institute\",\n    location: \"global_collaboration\",\n    funding: \"non_profit_grant\"\n  }\n} @0.92 // High confidence in this composite statement",
          "path": "advanced-features/maximum-feature-density.aiql"
        },
        {
          "label": "Multi-Context: Mars Colonization",
          "code": "// Multi-Context: Mars Colonization\n// ==============================================================================\n// This file demonstrates using multiple context parameters simultaneously.\n//\n// Key Concepts:\n// 1. Temporal Context (time:future): The statement applies to a future timeline.\n// 2. Spatial/Scope Context (scope:global): Applies to the general consensus reality.\n// 3. Probabilistic Assertion: Combining future context with confidence < 1.0.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// Future Prediction\n// Goal: predict the colonization of Mars.\n// Natural Language: \"In the future, Humans will colonize Mars (85% certainty).\"\n// ------------------------------------------------------------------------------\n!Assert(time:future, scope:global) {\n  <Mars> [colonized_by] <Humans> {\n    estimated_date: \"2050-2100\",\n    probability: 0.65,\n    milestone: \"first_permanent_habitat\"\n  }\n} @0.85",
          "path": "advanced-features/multi-context-mars-colonization.aiql"
        },
        {
          "label": "Relationship: Bidirectional Temporal",
          "code": "// Relationship: Bidirectional Temporal\n// ==============================================================================\n// This file demonstrates explicit relationship nodes for temporal synchronization.\n//\n// Key Concepts:\n// 1. !Relationship Intent: Defining meta-relations between other IDs.\n// 2. Bidirectional: Flagging a relation as symmetric (A <-> B).\n// 3. Simultaneity: Events occurring at the exact same time.\n// 4. Concurrency: Processes running in parallel intervals.\n// ==============================================================================\n\n@version:\"2.1.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Define Event A (Launch)\n// ------------------------------------------------------------------------------\n$id:apollo11_launch\n!Assert {\n  <Apollo11> [launched] <1969-07-16> {\n    location: \"Kennedy_Space_Center\"\n  }\n} @0.99\n\n// ------------------------------------------------------------------------------\n// 2. Define Event B (Broadcast)\n// ------------------------------------------------------------------------------\n$id:global_broadcast\n!Assert {\n  <TV> [broadcasted] <MoonLanding> {\n    viewers: \"600_million\"\n  }\n} @0.99\n\n// ------------------------------------------------------------------------------\n// 3. Link A and B (Simultaneity)\n// Goal: Explicitly state that Launch and Broadcast happened together.\n// ------------------------------------------------------------------------------\n!Relationship(type:temporal, source:$id:apollo11_launch, target:$id:global_broadcast) {\n  <LaunchEvent> [simultaneous] <BroadcastEvent>\n} @0.90\n\n// ------------------------------------------------------------------------------\n// 4. Concurrency Example (Parallel Tasks)\n// ------------------------------------------------------------------------------\n$id:ai_training\n!Task {\n  <GPU_Cluster> [trains] <LLM> { model_size: \"70B\" }\n} @0.95\n\n$id:data_preprocessing\n!Task {\n  <Pipeline> [processes] <Dataset>\n} @0.92\n\n!Relationship(type:temporal, source:$id:ai_training, target:$id:data_preprocessing) {\n  <Training> [concurrent] <Preprocessing>\n} @0.85",
          "path": "advanced-features/relationship-bidirectional-temporal.aiql"
        },
        {
          "label": "Relationship: Climate Causal Chain",
          "code": "// Relationship: Climate Causal Chain\n// ==============================================================================\n// This file demonstrates using explicit Relationship nodes for causality.\n//\n// Key Concepts:\n// 1. Causal Graph: Nodes are Events/Facts, Edges are Causal Links.\n// 2. !Relationship(type:causal): Meta-intent for defining edges between IDs.\n// 3. Chain Reaction: A causes B, B causes C.\n// ==============================================================================\n\n@version:\"2.1.0\"\n\n// ------------------------------------------------------------------------------\n// Step 1: Emissions\n// ------------------------------------------------------------------------------\n$id:co2_emissions\n!Assert {\n  <CO2Emissions> [increasing] <Atmosphere> {\n    rate: \"2ppm/year\"\n  }\n} @0.99\n\n// ------------------------------------------------------------------------------\n// Step 2: Global Warming\n// ------------------------------------------------------------------------------\n$id:global_warming\n!Assert {\n  <GlobalWarming> [threatening] <Ecosystems> {\n    temperature_rise: \"1.5C\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// Link 1 -> 2: Emissions CAUSE Warming\n// ------------------------------------------------------------------------------\n!Relationship(type:causal, source:$id:co2_emissions, target:$id:global_warming) {\n  <CO2Emissions> [causes] <GlobalWarming>\n} @0.92\n\n// ------------------------------------------------------------------------------\n// Step 3: Extreme Weather\n// ------------------------------------------------------------------------------\n$id:extreme_weather\n!Assert {\n  <ExtremeWeather> [increasing] <Frequency>\n} @0.90\n\n// ------------------------------------------------------------------------------\n// Link 2 -> 3: Warming TRIGGERS Weather Events\n// ------------------------------------------------------------------------------\n!Relationship(type:causal, source:$id:global_warming, target:$id:extreme_weather) {\n  <GlobalWarming> [triggers] <ExtremeWeather>\n} @0.88",
          "path": "advanced-features/relationship-climate-causation.aiql"
        },
        {
          "label": "Relationship: Historical Timeline",
          "code": "// Relationship: Historical Timeline\n// ==============================================================================\n// This file demonstrates temporal ordering using Relationship nodes.\n//\n// Key Concepts:\n// 1. Temporal Constraints: Before, after, during.\n// 2. Timeline Construction: Linking independent events into a narrative.\n// 3. Chronological Reasoning: Enabling the AI to understand cause-and-effect sequences.\n// ==============================================================================\n\n@version:\"2.1.0\"\n\n// ------------------------------------------------------------------------------\n// Step 1: French Revolution\n// ------------------------------------------------------------------------------\n$id:french_revolution\n!Assert {\n  <FrenchRevolution> [occurred_in] <1789> {\n    location: \"France\",\n    significance: \"high\"\n  }\n} @0.99\n\n// ------------------------------------------------------------------------------\n// Step 2: Napoleonic Wars\n// ------------------------------------------------------------------------------\n$id:napoleonic_wars\n!Assert {\n  <NapoleonicWars> [occurred_in] <1803-1815> {\n    continent: \"Europe\"\n  }\n} @0.99\n\n// ------------------------------------------------------------------------------\n// Link 1 -> 2: Revolution predicts/precedes Wars\n// ------------------------------------------------------------------------------\n!Relationship(type:temporal, source:$id:french_revolution, target:$id:napoleonic_wars) {\n  <FrenchRevolution> [before] <NapoleonicWars>\n} @0.95\n\n// ------------------------------------------------------------------------------\n// Step 3: World War I\n// ------------------------------------------------------------------------------\n$id:ww1\n!Assert {\n  <WorldWar1> [occurred_in] <1914-1918>\n} @0.99\n\n// ------------------------------------------------------------------------------\n// Link 2 -> 3: Wars precede WWI (Long-term historical flow)\n// ------------------------------------------------------------------------------\n!Relationship(type:temporal, source:$id:napoleonic_wars, target:$id:ww1) {\n  <NapoleonicWars> [before] <WorldWar1>\n} @0.98",
          "path": "advanced-features/relationship-historical-timeline.aiql"
        },
        {
          "label": "Relationship: Scientific Discovery",
          "code": "// Relationship: Scientific Discovery\n// ==============================================================================\n// This file demonstrates logical relationships in scientific discourse.\n//\n// Key Concepts:\n// 1. Support: Evidence strengthening a hypothesis (<Observation> [supports] <Theory>).\n// 2. Contradiction: Theories conflicting in specific contexts.\n// 3. Prediction: Theories implying the existence of phenomena before observation.\n// ==============================================================================\n\n@version:\"2.1.0\"\n\n// ------------------------------------------------------------------------------\n// 1. Theory: General Relativity\n// Prediction: Gravitational Waves exist.\n// ------------------------------------------------------------------------------\n$id:theory_relativity\n!Assert {\n  <GeneralRelativity> [predicts] <GravitationalWaves> {\n    author: \"Einstein\",\n    year: 1915\n  }\n} @0.99\n\n// ------------------------------------------------------------------------------\n// 2. Observation: LIGO\n// Fact: Gravitational Waves detected.\n// ------------------------------------------------------------------------------\n$id:observation_ligo\n!Assert {\n  <LIGO> [detected] <GravitationalWaves> {\n    year: 2015,\n    event: \"BH_merger\"\n  }\n} @0.99\n\n// ------------------------------------------------------------------------------\n// Logical Link: Observation Confirms Theory\n// ------------------------------------------------------------------------------\n!Relationship(type:logical, source:$id:observation_ligo, target:$id:theory_relativity) {\n  <Observation> [supports] <Theory> {\n    significance: \"Nobel_Prize\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// 3. Contradiction: Newtonian Gravity\n// Context: Strong gravitational fields (e.g., near Black Holes).\n// ------------------------------------------------------------------------------\n$id:newtonian_gravity\n!Assert {\n  <NewtonianGravity> [describes] <WeakFields>\n} @0.98\n\n// Einstein's theory CONTRADICTS Newton's in extreme contexts\n!Relationship(type:logical, source:$id:theory_relativity, target:$id:newtonian_gravity) {\n  <Relativity> [contradicts] <NewtonianGravity> {\n    context: \"strong_gravitational_fields\"\n  }\n} @0.85",
          "path": "advanced-features/relationship-scientific-discovery.aiql"
        },
        {
          "label": "Relationship: Workflow Dependencies",
          "code": "// Relationship: Workflow Dependencies\n// ==============================================================================\n// This file demonstrates modeling project dependencies.\n//\n// Key Concepts:\n// 1. Dependency Graph: Tasks linked by [depends_on] relations.\n// 2. Causal Type: A task *causes* the readiness of the next task.\n// 3. Scheduling: AI agents can use this graph to sequence actions.\n// ==============================================================================\n\n@version:\"2.1.0\"\n\n// ------------------------------------------------------------------------------\n// Phase 1: Design\n// ------------------------------------------------------------------------------\n$id:design_phase\n!Task {\n  <Designer> [creates] <UIPrototype> {\n    tool: \"Figma\",\n    deadline: \"Week1\"\n  }\n} @0.95\n\n// ------------------------------------------------------------------------------\n// Phase 2: Implementation\n// ------------------------------------------------------------------------------\n$id:implementation\n!Task {\n  <Developer> [implements] <Frontend> {\n    framework: \"React\"\n  }\n} @0.90\n\n// Dependency: Code starts after Design\n!Relationship(type:causal, source:$id:implementation, target:$id:design_phase) {\n  <Implementation> [depends_on] <DesignPhase>\n} @0.98\n\n// ------------------------------------------------------------------------------\n// Phase 3: Testing\n// ------------------------------------------------------------------------------\n$id:testing\n!Task {\n  <Tester> [validates] <Features>\n} @0.92\n\n// Dependency: Testing starts after Code\n!Relationship(type:causal, source:$id:testing, target:$id:implementation) {\n  <Testing> [depends_on] <Implementation>\n} @0.99",
          "path": "advanced-features/relationship-workflow-dependencies.aiql"
        },
        {
          "label": "Research Provenance: LLM Paper",
          "code": "// Research Provenance: LLM Paper\n// ==============================================================================\n// This file demonstrates citation and provenance tracking.\n//\n// Key Concepts:\n// 1. @origin: The primary source of the knowledge (e.g., DOI).\n// 2. @cite: Supporting references (Array of identifiers).\n// 3. Academic Integrity: Essential for AI systems generating research outputs.\n// ==============================================================================\n\n@version:\"0.4.0\"\n@origin:\"doi:10.1234/ai-reasoning-2026\"\n@cite:[\"arxiv:2401.12345\", \"doi:10.5555/foundation\", \"isbn:978-0-262-03384-8\"]\n\n// ------------------------------------------------------------------------------\n// Main Hypothesis\n// Supported by the cited Papers.\n// ------------------------------------------------------------------------------\n!Assert {\n  <LargeLanguageModels> [demonstrate] <EmergentReasoning> {\n    capability: \"chain-of-thought\",\n    threshold: \"100B+ parameters\"\n  }\n} @0.88\n\n// ------------------------------------------------------------------------------\n// Specific Finding\n// Overriding citations for a specific block ($id:finding02).\n// ------------------------------------------------------------------------------\n$id:finding02\n@cite:[\"doi:10.1145/experiment\"]\n!Assert {\n  <ScalingLaws> [predict] <PerformanceGains> {\n    domain: \"mathematical_reasoning\",\n    confidence_interval: \"95%\"\n  }\n} @0.92",
          "path": "advanced-features/research-provenance-llm-paper.aiql"
        },
        {
          "label": "Rich Context: AGI Speculation",
          "code": "// Rich Context: AGI Speculation\n// ==============================================================================\n// This file demonstrates powerful context-aware queries.\n//\n// Key Concepts:\n// 1. time:future: Speculating about events that haven't happened.\n// 2. mode:possibility/hypothetical: Exploring potential futures, not facts.\n// 3. scope:global/research: Limiting the query domain.\n// ==============================================================================\n\n@version:\"1.0.0\"\n\n// ------------------------------------------------------------------------------\n// Future Possibility Query\n// \"Is it possible that AI will achieve AGI in the future?\"\n// ------------------------------------------------------------------------------\n!Query(time:future, mode:possibility, scope:global) {\n  <AI> [achieves] <AGI> {\n    capability: \"general_reasoning\",\n    alignment: \"human_values\"\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Historical Fact Query\n// \"Did Deep Learning enable the AI Revolution in the past?\"\n// ------------------------------------------------------------------------------\n!Query(time:past, scope:historical) {\n  <DeepLearning> [enabled] <AIRevolution> {\n    breakthrough: \"neural_networks\",\n    year_range: \"2010-2025\"\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Hypothetical Scenario (High Temperature)\n// \"Hypothetically, would Quantum Computing exponentially accelerate AI?\"\n// ------------------------------------------------------------------------------\n$id:speculation_001\n~temp:0.9\n!Query(mode:hypothetical, scope:research) {\n  <QuantumComputing> [accelerates] <AITraining> {\n    speedup: \"exponential\",\n    timeline: \"2030s\"\n  }\n} @0.70",
          "path": "advanced-features/rich-context-agi-speculation.aiql"
        },
        {
          "label": "Semantic Taxonomy: Animal Kingdom",
          "code": "// Semantic Taxonomy: Animal Kingdom\n// ==============================================================================\n// This file demonstrates hierarchical knowledge definition.\n//\n// Key Concepts:\n// 1. [is_a] Relation: The fundamental operator for taxonomy.\n// 2. Inheritance: Properties defined at higher levels (Mammal) apply to lower (Human).\n// 3. Sequential Definition (##seq): Building the tree from root to leaf.\n// ==============================================================================\n\n@version:\"1.0.0\"\n$$group:ontology_definition\n\n// ------------------------------------------------------------------------------\n// Level 1: Mammal -> Animal\n// ------------------------------------------------------------------------------\n##seq:1\n!Assert {\n  <Mammal> [is_a] <Animal> {\n    defining_trait: \"warm_blooded\",\n    reproduction: \"live_birth\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// Level 2: Primate -> Mammal\n// ------------------------------------------------------------------------------\n##seq:2\n!Assert {\n  <Primate> [is_a] <Mammal> {\n    defining_trait: \"opposable_thumbs\",\n    brain_size: \"large\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// Level 3: Human -> Primate\n// ------------------------------------------------------------------------------\n##seq:3\n!Assert {\n  <Human> [is_a] <Primate> {\n    defining_trait: \"advanced_cognition\",\n    language_capable: \"yes\",\n    tool_use: \"complex\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// Level 3: Chimpanzee -> Primate\n// ------------------------------------------------------------------------------\n##seq:4\n!Assert {\n  <Chimpanzee> [is_a] <Primate> {\n    genetic_similarity_to_human: \"0.98\",\n    social_structure: \"hierarchical\"\n  }\n} @1.0\n\n// ------------------------------------------------------------------------------\n// Logic Check\n// Goal: Verify that Humans inherit properties from Animals (via Primate -> Mammal).\n// ------------------------------------------------------------------------------\n!Query(mode:inheritance) {\n  <Human> [inherits_properties_from] <Animal>\n}",
          "path": "advanced-features/semantic-taxonomy-animal-kingdom.aiql"
        },
        {
          "label": "Spatial Swarm Intelligence",
          "code": "// Spatial Swarm Intelligence (v2.6.0)\n// ==============================================================================\n// This file demonstrates Swarm Intelligence primitives (Consensus/Coordinate).\n//\n// Key Concepts:\n// 1. !Consensus: Swarm agreeing on a shared state/strategy.\n// 2. !Coordinate: Assigning roles and goals to swarm members.\n// 3. Spatial Context: Using coordinate systems for geolocation.\n// ==============================================================================\n\n// ------------------------------------------------------------------------------\n// 1. Swarm Consensus\n// Goal: Agree on a search strategy with 80% threshold.\n// ------------------------------------------------------------------------------\n!Consensus (scope:local) {\n  topic = <SearchStrategy>\n  participants = [<DroneA>, <DroneB>, <DroneC>]\n  threshold = 0.8\n  timeout = 5000\n}\n\n// ------------------------------------------------------------------------------\n// 2. Swarm Coordination\n// Goal: Execute the exploration mission using decentralized strategy.\n// ------------------------------------------------------------------------------\n!Coordinate {\n  goal = <Exploration>\n  participants = [<Swarm>]\n  strategy = \"decentralized\"\n}\n\n// ------------------------------------------------------------------------------\n// 3. Spatial Awareness\n// Goal: Define positions using literal coordinates and variable sectors.\n// ------------------------------------------------------------------------------\n!Assert {\n  <DroneA> [is_at] space:literal(37.7749, -122.4194)\n  <Target> [is_in] space:variable(sector_7)\n}\n",
          "path": "advanced-features/spatial-swarm-intelligence.aiql"
        }
      ]
    }
  ]
};
